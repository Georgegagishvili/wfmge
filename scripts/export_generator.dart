import 'dart:io';
import 'package:path/path.dart' as p;

// ignore_for_file: avoid_print
// ignore_for_file: depend_on_referenced_packages

class Folder {
  /// Represents a folder to process for generating exports.
  final String path;

  /// An optional additional exports to include in the generated file.
  /// e.g [`package:provider/provider.dart`].
  final List<String>? additionalExports;

  const Folder({required this.path, this.additionalExports});
}

/// A list of folders to process for generating exports.
///
const folders = [
  Folder(path: 'src/commons'),
  Folder(path: 'src/features'),
  Folder(path: 'src/routing'),
  Folder(path: 'src/services'),
  Folder(path: 'src/utils'),
];

/// An optional list of folders to ignore when generating exports.
/// You can also specify ignored folders via the --ignore argument (comma-separated).
const ignoredFolders = <String>[
  'src/commons/models/data_contracts',
  'src/commons/models/swagger',
  'src/services/http/testing'
];

/// The root path where folders are located.
///
const rootPath = 'lib';

/// Generates exports.dart files for specified folders in the lib directory.
/// run `dart run .\export_generator.dart` to execute the script.
/// you can also specify a folder path to process single folder, e.g., `dart run .\export_generator.dart models`.
///
void main(List<String> arguments) async {
  final pubspec = File('pubspec.yaml');

  if (!pubspec.existsSync()) {
    print(
      'pubspec.yaml not found. Run this script from the root of your package.',
    );
    exit(1);
  }

  final pubspecContent = await pubspec.readAsLines();
  final nameLine = pubspecContent.firstWhere(
    (line) => line.trim().startsWith('name:'),
    orElse: () => '',
  );

  if (nameLine.isEmpty) {
    print('Could not find package name in pubspec.yaml');
    exit(1);
  }

  final packageName = nameLine.split(':')[1].trim();

  // Parse ignored folders from command-line arguments
  final argIgnored = arguments.firstWhere(
    (arg) => arg.startsWith('--ignore='),
    orElse: () => '',
  );
  final argIgnoredFolders = argIgnored.isNotEmpty
      ? argIgnored
            .replaceFirst('--ignore=', '')
            .split(',')
            .map((s) => s.trim())
            .where((s) => s.isNotEmpty)
            .toList()
      : <String>[];
  final allIgnoredFolders = {...ignoredFolders, ...argIgnoredFolders};

  final foldersToProcess = arguments.isEmpty || arguments[0].startsWith('--')
      ? folders
      : folders.where((f) => f.path == arguments[0]).toList();

  if (foldersToProcess.isEmpty) {
    print('No matching folders found to process.');
    exit(1);
  }

  print('ᕁ᙮ᕁᕽᕽᕁ᙮᙮ᕁᕽᕽᕁ᙮ᕁ' * 5);

  for (final folder in foldersToProcess) {
    final targetDir = Directory('$rootPath/${folder.path}');

    if (!targetDir.existsSync()) {
      print('Directory $rootPath/${folder.path} does not exist. Skipping.');
      continue;
    }

    final scriptPath = Platform.script.toFilePath();
    final relativeScriptPath = p.relative(
      scriptPath,
      from: Directory.current.path,
    );
    final exportFile = File('$rootPath/${folder.path}/exports.dart');
    final buffer = StringBuffer()
      ..writeln('/*')
      ..writeln(' * Generated by export_generator.dart')
      ..writeln(' * Do not edit this file manually.')
      ..writeln(' * To regenerate, run `dart run .\\$relativeScriptPath`')
      ..writeln(' */')
      ..writeln();

    if (folder.additionalExports != null) {
      for (final export in folder.additionalExports!) {
        buffer.writeln("export '$export';");
      }
      buffer.writeln();
    }
    final Map<String, List<String>> exportsByFolder = {};

    for (final entity in targetDir.listSync(recursive: true)) {
      if (entity is File &&
          entity.path.endsWith('.dart') &&
          !entity.path.endsWith('exports.dart')) {
        // Check if file is in an ignored folder
        final pathFromLib = entity.uri.pathSegments
            .skipWhile((s) => s != rootPath)
            .skip(1)
            .join('/');
        final normalizedPath = p.posix.normalize(pathFromLib);
        // If any ignored folder is a prefix of the file's path, skip it
        if (allIgnoredFolders.any(
          (ignored) =>
              normalizedPath == ignored ||
              normalizedPath.startsWith('$ignored/'),
        )) {
          continue;
        }
        final folderPath = p.posix.dirname(normalizedPath);
        final exportLine = "export 'package:$packageName/$normalizedPath';";
        exportsByFolder.putIfAbsent(folderPath, () => []).add(exportLine);
      }
    }

    final exportFolders = exportsByFolder.keys.toList()..sort();

    for (var i = 0; i < exportFolders.length; i++) {
      final folderPath = exportFolders[i];
      final exports = exportsByFolder[folderPath]!..sort();

      for (final exportLine in exports) {
        buffer.writeln(exportLine);
      }
      if (i < exportFolders.length - 1) {
        buffer.writeln();
      }
    }

    await exportFile.writeAsString(buffer.toString());
    print('Exports file generated at $rootPath/${folder.path}/exports.dart');
  }
  print('ᕁ᙮ᕁᕽᕽᕁ᙮᙮ᕁᕽᕽᕁ᙮ᕁ' * 5);
}
